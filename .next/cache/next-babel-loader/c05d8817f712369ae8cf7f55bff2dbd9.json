{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport { persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nconst initialState = {\n  slates: {},\n  importErrors: [],\n  stack: [],\n  stacks: [],\n  stackCounts: [],\n  results: [],\n  pool: [],\n  view: 'slatepicker',\n  showPoolTools: false\n};\n\nconst reducer = (state = initialState, {\n  type,\n  payload\n}) => {\n  const stackCounts = [...state.stackCounts];\n\n  switch (type) {\n    case 'SET_SLATES':\n      return _objectSpread({}, state, {\n        slates: _objectSpread({}, payload)\n      });\n\n    case 'SET_SELECTED_SLATE':\n      return _objectSpread({}, state, {\n        selectedSlate: payload\n      });\n\n    case 'CLEAR_IMPORT_ERRORS':\n      return _objectSpread({}, state, {\n        importErrors: []\n      });\n\n    case 'ADD_IMPORT_ERROR':\n      return _objectSpread({}, state, {\n        importErrors: state.importErrors.concat([payload])\n      });\n\n    case 'SET_RAW_PROJECTION':\n      return _objectSpread({}, state, {\n        rawProjection: payload\n      });\n\n    case 'SET_PROJECTION':\n      return _objectSpread({}, state, {\n        projection: payload\n      });\n\n    case 'CLEAR_STACK':\n      return _objectSpread({}, state, {\n        stack: []\n      });\n\n    case 'ADD_STACK':\n      return _objectSpread({}, state, {\n        stacks: state.stacks.concat([payload]),\n        stackCounts: state.stackCounts.concat([0])\n      });\n\n    case 'REMOVE_STACK':\n      return _objectSpread({}, state, {\n        stacks: state.stacks.filter((stack, i) => i !== payload),\n        stackCounts: state.stackCounts.filter((n, i) => i !== payload)\n      });\n\n    case 'ADD_PLAYER_TO_STACK':\n      return _objectSpread({}, state, {\n        stack: state.stack.concat([payload])\n      });\n\n    case 'REMOVE_PLAYER_FROM_STACK':\n      return _objectSpread({}, state, {\n        stack: state.stack.filter(player => player.playerId !== payload.playerId)\n      });\n\n    case 'SET_STACK_N':\n      const {\n        i,\n        n\n      } = payload;\n      stackCounts[i] = Number(n);\n      return _objectSpread({}, state, {\n        stackCounts\n      });\n\n    case 'ADD_RESULT':\n      return _objectSpread({}, state, {\n        results: state.results.concat(payload)\n      });\n\n    case 'REMOVE_RESULT':\n      return _objectSpread({}, state, {\n        results: state.results.filter((result, i) => i !== payload)\n      });\n\n    case 'ADD_PLAYER_TO_POOL':\n      return _objectSpread({}, state, {\n        pool: state.pool.concat([payload])\n      });\n\n    case 'REMOVE_PLAYER_FROM_POOL':\n      return _objectSpread({}, state, {\n        pool: state.pool.filter(player => player.playerId !== payload.playerId)\n      });\n\n    case 'SET_VIEW':\n      return _objectSpread({}, state, {\n        view: payload\n      });\n\n    case 'MOVE_STACK':\n      const {\n        j,\n        which\n      } = payload;\n      const stacks = state.stacks.concat([]);\n      const stack = stacks[j];\n\n      if (which === \"right\" && j < stacks.length - 1) {\n        const right = stacks[j + 1];\n        stacks.splice(j, 1, right);\n        stacks.splice(j + 1, 1, stack);\n      }\n\n      if (which === \"left\" && j > 0) {\n        const left = stacks[j - 1];\n        stacks.splice(j, 1, left);\n        stacks.splice(j - 1, 1, stack);\n      }\n\n      return _objectSpread({}, state, {\n        stacks,\n        stackCounts\n      });\n\n    case 'CLEAR_POOL':\n      return _objectSpread({}, state, {\n        pool: []\n      });\n\n    case 'SET_POOL_SALARY_RANGE':\n      return _objectSpread({}, state, {\n        poolSalaryRange: payload\n      });\n\n    case 'TOGGLE_POOL_TOOLS':\n      return _objectSpread({}, state, {\n        showPoolTools: !state.showPoolTools\n      });\n\n    case 'PURGE':\n      return state;\n\n    default:\n      return state;\n  }\n};\n\nconst persistConfig = {\n  key: 'primary',\n  storage\n};\nconst persistedReducer = persistReducer(persistConfig, reducer);\nexport const initializeStore = (preloadedState = initialState) => {\n  return createStore(persistedReducer, preloadedState, composeWithDevTools(applyMiddleware()));\n};","map":null,"metadata":{},"sourceType":"module"}