{"ast":null,"code":"import { solve } from './solver';\nconst queue = [];\nconst Queue = {\n  register: (n, maxIterations, model, ownership, players, sport, site, type) => {\n    queue.push(solve(n, maxIterations, model, ownership, players, sport, site, type));\n  },\n  go: () => {\n    const results = [];\n\n    while (queue.length) {\n      const top = queue.shift();\n      const response = top.go();\n\n      if (response.notFeasible || top.isDone()) {\n        top.results.forEach(result => results.push(result));\n        continue;\n      }\n\n      queue.push(top);\n    }\n\n    return results;\n  }\n};\nexport default Queue;","map":{"version":3,"sources":["/Users/jwesto1/Code/jaw187/dfs-solver/solver/queue.js"],"names":["solve","queue","Queue","register","n","maxIterations","model","ownership","players","sport","site","type","push","go","results","length","top","shift","response","notFeasible","isDone","forEach","result"],"mappings":"AAAA,SAASA,KAAT,QAAsB,UAAtB;AACA,MAAMC,KAAK,GAAG,EAAd;AAEA,MAAMC,KAAK,GAAG;AACZC,EAAAA,QAAQ,EAAE,CAACC,CAAD,EAAIC,aAAJ,EAAmBC,KAAnB,EAA0BC,SAA1B,EAAqCC,OAArC,EAA8CC,KAA9C,EAAqDC,IAArD,EAA2DC,IAA3D,KAAoE;AAC5EV,IAAAA,KAAK,CAACW,IAAN,CAAWZ,KAAK,CAACI,CAAD,EAAIC,aAAJ,EAAmBC,KAAnB,EAA0BC,SAA1B,EAAqCC,OAArC,EAA8CC,KAA9C,EAAqDC,IAArD,EAA2DC,IAA3D,CAAhB;AACD,GAHW;AAIZE,EAAAA,EAAE,EAAE,MAAM;AACR,UAAMC,OAAO,GAAG,EAAhB;;AAEA,WAAOb,KAAK,CAACc,MAAb,EAAqB;AACnB,YAAMC,GAAG,GAAGf,KAAK,CAACgB,KAAN,EAAZ;AACA,YAAMC,QAAQ,GAAGF,GAAG,CAACH,EAAJ,EAAjB;;AAEA,UAAIK,QAAQ,CAACC,WAAT,IAAwBH,GAAG,CAACI,MAAJ,EAA5B,EAA0C;AACxCJ,QAAAA,GAAG,CAACF,OAAJ,CAAYO,OAAZ,CAAqBC,MAAD,IAAYR,OAAO,CAACF,IAAR,CAAaU,MAAb,CAAhC;AACA;AACD;;AAEDrB,MAAAA,KAAK,CAACW,IAAN,CAAWI,GAAX;AACD;;AAED,WAAOF,OAAP;AACD;AApBW,CAAd;AAuBA,eAAeZ,KAAf","sourcesContent":["import { solve } from './solver';\nconst queue = [];\n\nconst Queue = {\n  register: (n, maxIterations, model, ownership, players, sport, site, type) => {\n    queue.push(solve(n, maxIterations, model, ownership, players, sport, site, type))\n  },\n  go: () => {\n    const results = [];\n\n    while (queue.length) {\n      const top = queue.shift();\n      const response = top.go();\n\n      if (response.notFeasible || top.isDone()) {\n        top.results.forEach((result) => results.push(result));\n        continue;\n      }\n\n      queue.push(top);\n    }\n\n    return results;\n  }\n}\n\nexport default Queue;\n"]},"metadata":{},"sourceType":"module"}